Context is not a state management system by itself.

Context provides a way to pass data through the component tree without having to pass props down manually at every level.

In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application.

Context is designed to share data that can be considered “global” for a tree of React components, such as the current authenticated user, theme, or preferred language.

By using Context, we can avoid passing props through intermediate elements.

Context is primarily used when some data needs to be accessible by many components at different nesting levels. Apply it sparingly because it makes component resuse more difficult.

If you only want to avoid passing some props through many levels, component composition is often a simpler solution than context.

Component composition is sufficient for many cases when you need to decouple a child from its immediate parents. You can take it even further with render props if the child needs to communicate with the parent before rendering.

Sometimes the same data needs to be accessible by many components in the tree, and at different nesting levels. Context lets you “broadcast” such data, and changes to it, to all components below. Common examples where using Context might be simpler than the alternatives include managing the current locale, theme, or a data cache.

The method createContext creates a Context object. When React renders a component that subscribes to this Context object it will read the current Context value from the closest matching Provider above it in the tree.

React provides a method called createContext which will generate a composite component made up of two smaller components: Provider and Consumer. Provider is responsible for holding data, while Consumer is responsible for accessing it.

Handling authentication, themes, and API data can all be maintained by independent Contexts. To use them simultaneusly simply stack the providers 

The defaultValue argument is only used when a component does not have a matching Provider above it in the tree. This can be helpful for testing components in isolation without wrapping them. Note: passing undefined as a Provider value does not cause consuming components to use defaultValue.

Every Context object comes with a Provider React component that allows consuming components to subscribe to Context changes.

Context provides a way to share values between components without having to explicitly pass a prop through every level of the tree.

Accepts a value prop to be passed to consuming components that are descendants of this Provider. One provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.

All consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes.

The propagation from Provider to its descendant consumers is not subject to the shouldComponentUpdate method, so the consumer is updated even when an ancestor component bails out of the update.




